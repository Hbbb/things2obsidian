// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package db

import (
	"context"
)

const getTodayTasks = `-- name: GetTodayTasks :many
SELECT uuid, leavesTombstone, creationDate, userModificationDate, type, status, stopDate, trashed, title, notes, notesSync, cachedTags, start, startDate, startBucket, reminderTime, lastReminderInteractionDate, deadline, deadlineSuppressionDate, t2_deadlineOffset, "index", todayIndex, todayIndexReferenceDate, area, project, heading, contact, untrashedLeafActionsCount, openUntrashedLeafActionsCount, checklistItemsCount, openChecklistItemsCount, rt1_repeatingTemplate, rt1_recurrenceRule, rt1_instanceCreationStartDate, rt1_instanceCreationPaused, rt1_instanceCreationCount, rt1_afterCompletionReferenceDate, rt1_nextInstanceStartDate, experimental, repeater, repeaterMigrationDate
FROM TMTask
WHERE todayIndexReferenceDate is not null
  AND start = 1
  AND status = 0
  AND trashed = 0
`

func (q *Queries) GetTodayTasks(ctx context.Context) ([]TMTask, error) {
	rows, err := q.db.QueryContext(ctx, getTodayTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TMTask
	for rows.Next() {
		var i TMTask
		if err := rows.Scan(
			&i.Uuid,
			&i.LeavesTombstone,
			&i.CreationDate,
			&i.UserModificationDate,
			&i.Type,
			&i.Status,
			&i.StopDate,
			&i.Trashed,
			&i.Title,
			&i.Notes,
			&i.NotesSync,
			&i.CachedTags,
			&i.Start,
			&i.StartDate,
			&i.StartBucket,
			&i.ReminderTime,
			&i.LastReminderInteractionDate,
			&i.Deadline,
			&i.DeadlineSuppressionDate,
			&i.T2DeadlineOffset,
			&i.Index,
			&i.TodayIndex,
			&i.TodayIndexReferenceDate,
			&i.Area,
			&i.Project,
			&i.Heading,
			&i.Contact,
			&i.UntrashedLeafActionsCount,
			&i.OpenUntrashedLeafActionsCount,
			&i.ChecklistItemsCount,
			&i.OpenChecklistItemsCount,
			&i.Rt1RepeatingTemplate,
			&i.Rt1RecurrenceRule,
			&i.Rt1InstanceCreationStartDate,
			&i.Rt1InstanceCreationPaused,
			&i.Rt1InstanceCreationCount,
			&i.Rt1AfterCompletionReferenceDate,
			&i.Rt1NextInstanceStartDate,
			&i.Experimental,
			&i.Repeater,
			&i.RepeaterMigrationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
